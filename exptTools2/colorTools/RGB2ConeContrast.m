function [lmsContrast, lmsBack] = RGB2ConeContrast(display,stimRGB,backRGB,sensors)% %   [lmsContrast, lmsBack] = RGB2ConeContrast(display,stimRGB,[backRGB],[sensors])%   % AUTHOR:  Wandell% DATE:  09.11.98% PURPOSE:% %   Compute the vector of cone contrasts (yes, real contrasts)%   when using stimRGB and backRGB.  The structures (display,%   backRGB, and stimRGB) define the characteristics of the%   display, background and contrast stimulus.  The sensors%   default to the Stockman sensors. % % ARGUMENTS:%   %   display:  .spectra    display primaries (361x3)%   stimRGB:  .dir  (color direction) and .scale (vector)%   backRGB:  .dir  (color direction) and .scale (scalar) - RGB direction.  Default [0.5 0.5 0.5]%   sensors:  (optional) matrix 361x3 of sensor sensitivities.%             Default Stockman.%   %   lmsContrast:  The vector of cone contrasts under these conditions%   lmsBack:      The lms values of the background% % BUGS:%% HISTORY:% % 98/11/05 bob: added default background settings% 11/18/98 wap: swapped location of background settings in argument list.%				rotated date convention to the left :-).% 2010.04.02 RFD: allow an rgb2lms matrix in place of diaplay & sensors%if ~exist('backRGB','var')	backRGB.dir = [1 1 1]';	backRGB.scale = .5;endif(~isstruct(display) && numel(display)==9)    % then display is a 3x3 rgb2lms matrix.    rgb2lms = display;else    if ~exist('sensors','var')        load stockman        sensors = stockman;    end    if ~isfield(display,'spectra')        error('The display structure requires a spectra field');    end    rgb2lms = sensors'*display.spectra;endlmsBack = rgb2lms*(backRGB.dir*backRGB.scale);lmsContrast = zeros(3,length(stimRGB.scale));for ii=1:length(stimRGB.scale)  lmsStimPlusBack = rgb2lms*(stimRGB.scale(ii)*stimRGB.dir) + lmsBack;  lmsContrast(:,ii) = (lmsStimPlusBack - lmsBack) ./ lmsBack;endreturn